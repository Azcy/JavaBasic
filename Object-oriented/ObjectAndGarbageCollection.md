# 对象与垃圾回收
### 垃圾回收机制的特征
1. 只负责回收堆内存中的对象，不会回收任何物理资源（例如数据库连接、网络IO等资源）.
2. 程序无法进去控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地事情引用后，系统就会在合适的时候回收它所占的内存。
3. 在垃圾回收机制回收任何对象之前，总会先调用finalize（）方法，该方法可能使对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。

### 对象在内存中的状态
当一个对象在**堆内存**中运行时，根据它被应用变量所引用的状态，可把它分为三种状态：

**可达状态：**当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态。

**可恢复状态：**如果程序中某个对象不再有任何引用变量引用它，它就进入可恢复状态。

**不可达状态：**当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize（）方法后依然没有使该对象变成可达状态，那么这个对象将永久性地失去引用，最后变成不可达状态。

**对象的转换示意图：**
![](https://github.com/Azcy/JavaBasic/blob/master/images/ObjectTypeChange.jpg)


### 强制垃圾回收
只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。

**两种方式：**
1. 调用System类的gc()静态方法：System.gc()。
2. 调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc()。

### finalize方法
Java提供了默认机制来清理该对象的资源，这个机制就是finalize()方法。

该方法是定义在Object类的实例方法，方法原形：
	
	protected void finalize() throws Throwsable

### finalize()方法的4个特点
1. 永远不要主动调用某个对象的finalize()方法，该方法应该交给垃圾回收机制调用。
2. finalize()方法何时被调用，是否被调用具有不确定性，不要把它当成一定会执行的方法。
3. 当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。
4. 当JVM执行finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续进行。

